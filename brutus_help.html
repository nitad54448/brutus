<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brutus Indexing - Technical Guide</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script typeF="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #3b82f6;
            --text-light: #f3f4f6;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
            --content-bg: #ffffff;
            --content-text: #1f2937;
            --content-heading: #111827;
            --code-bg: #f3f4f6;
            --code-text: #111827;
        }
        body {
            font-family: 'Inter', sans-serif; margin: 0; background-color: var(--content-bg);
            color: var(--content-text); line-height: 1.7; display: flex;
            height: 100vh; overflow: hidden;
        }
        #left-panel {
            width: 280px; flex-shrink: 0; background-color: var(--dark-bg);
            color: var(--text-medium); padding: 2rem; overflow-y: auto;
            border-right: 1px solid var(--border-color);
        }
        #left-panel .logo {
            font-size: 1.5rem; font-weight: 700; color: var(--text-light);
            margin-bottom: 2rem;
        }
        #left-panel .logo span { color: var(--primary-accent); }
        #toc { list-style: none; padding: 0; margin: 0; }
        #toc li a {
            display: block; color: var(--text-dark); text-decoration: none;
            padding: 0.6rem 1rem; border-radius: 0.375rem; font-weight: 500;
            font-size: 0.9rem; transition: background-color 0.2s, color 0.2s;
            border-left: 3px solid transparent;
        }
        #toc li a:hover { background-color: var(--medium-bg); color: var(--text-light); }
        #toc li a.active {
            background-color: var(--light-bg); color: var(--text-light);
            border-left-color: var(--primary-accent); font-weight: 600;
        }
        #main-content { flex-grow: 1; overflow-y: auto; padding: 3rem 4rem; }
        section {
            margin-bottom: 4rem; padding-top: 2rem; border-top: 1px solid #e5e7eb;
        }
        section:first-child { padding-top: 0; border-top: none; }
        h1, h2, h3, h4 {
            color: var(--content-heading); font-weight: 700; line-height: 1.3;
            margin-top: 1.5em; margin-bottom: 1em;
        }
        h1 { font-size: 2.5rem; }
        h2 { font-size: 2rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.5rem; }
        h3 { font-size: 1.5rem; }
        h4 { font-size: 1.2rem; }
        p, li { margin-bottom: 1rem; }
        ul, ol { padding-left: 1.5rem; }
        a { color: var(--primary-accent); text-decoration: none; font-weight: 500; }
        a:hover { text-decoration: underline; }
        code {
            font-family: 'Source Code Pro', monospace; background-color: var(--code-bg);
            color: var(--code-text); padding: 0.2em 0.4em;
            border-radius: 0.25rem; font-size: 0.9em;
        }
        pre {
            background-color: var(--code-bg); border-radius: 0.5rem; padding: 1rem;
            overflow-x: auto; font-size: 0.85rem; line-height: 1.5;
        }
        pre code { padding: 0; background: none; }
        blockquote {
            margin-left: 0; padding: 1rem 1.5rem; border-left: 4px solid var(--primary-accent);
            background-color: #f9fafb; color: #4b5563;
        }
        blockquote strong {
            display: block; margin-bottom: 0.5rem; font-weight: 600; color: #111827;
        }
        table {
            width: 100%; border-collapse: collapse; margin-bottom: 1.5rem; font-size: 0.9rem;
        }
        th, td { padding: 0.75rem 1rem; border: 1px solid #d1d5db; text-align: left; }
        th { background-color: #f3f4f6; font-weight: 600; }
        .footer {
            text-align: center; margin-top: 4rem; padding-top: 2rem;
            border-top: 1px solid #e5e7eb; font-size: 0.85rem; color: #6b7280;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #aaa; }
    </style>
</head>
<body>
    <aside id="left-panel">
        <div class="logo">Help Guide: <span>Brutus</span></div>
        <nav>
            <ul id="toc">
                <li><a href="#introduction" class="active">Technical Overview</a></li>
                <li><a href="#quick-start">Quick Start Guide</a></li>
                <li><a href="#ui">The User Interface</a></li>
                <li><a href="#peak-finding">Peak Finding</a></li>
                <li><a href="#indexing-method">Indexing Algorithm</a></li>
                <li><a href="#evaluating-solutions">Evaluating Solutions</a></li>
                <li><a href="#space-group-analysis">Space Group Analysis</a></li>
                <li><a href="#advanced-topics">Advanced Topics</a></li>
                <li><a href="#troubleshooting">Troubleshooting</a></li>
                <li><a href="#references">References</a></li>
            </ul>
        </nav>
    </aside>

    <main id="main-content">
        <!-- INTRODUCTION -->
        <section id="introduction">
            <h1>Technical Overview & Methodology</h1>
            <p>
                This document is a technical reference for the Brutus powder indexing software. It explains the main algorithms, search parameters,
                and methodology, and is intended for users familiar with powder X-ray diffraction. As the name of the program suggests it, this is brute force method (force is not necessarily smart).
            </p>

            <h3>Core Goal</h3>
            <p>
                The aim of <em>ab initio</em> powder indexing is to determine the unit-cell parameters
                ($a, b, c, \alpha, \beta, \gamma$) from a list of observed diffraction peak positions ($2\theta$).
                Brutus performs this task using a system-specific, exhaustive search algorithm.
            </p>
            <p>
                The central assumption is that a small subset of the most intense, low-angle reflections corresponds
                to simple crystal planes with low-integer Miller indices $(hkl)$. For a given crystal system,
                the program chooses exactly as many observed peaks as there are unknown lattice parameters, and solves
                the resulting system of linear equations.
            </p>

            <h3>Q-Space Formulation</h3>
            <p>
                All peak positions are first converted from $2\theta$ to Q-space, where $Q = 1/d^2$.
                The general quadratic relationship between $Q$, the Miller indices, and the reciprocal cell parameters
                ($A, B, C, D, E, F$) is
            </p>
            <p>
                $$ Q_{hkl} = Ah^2 + Bk^2 + Cl^2 + Dkl + Ehl + Fhk $$
            </p>
            <p>
                Brutus solves for these reciprocal parameters (or the subset relevant to the current crystal system),
                then converts them to real-space cell parameters. Each candidate cell is refined immediately and scored
                against the full peak list.
            </p>
        </section>

        <!-- QUICK START -->
        <section id="quick-start">
            <h2>Quick Start Guide</h2>
            <p>Use the following workflow for a typical single-phase powder pattern.</p>
            <ol>
                <li>
                    <strong>Load the data file.</strong>
                    Click <code>Select Data File</code>. Supported formats include <code>.xy</code>, <code>.xrdml</code>, <code>.ras</code>, and others.
                </li>
                <li>
                    <strong>Detect peaks.</strong>
                    On the <strong>Peaks</strong> tab, adjust the <code>Min peak (%)</code>, <code>Radius (pts)</code>, and <code>Points</code>
                    sliders until the automatically detected peaks match the visual pattern.
                </li>
                <li>
                    <strong>Curate the peak list.</strong>
                    Carefully review all peaks:
                    <ul>
                        <li>Edit $2\theta$ positions for accuracy.</li>
                        <li>Delete spurious peaks (noise, Kα<sub>2</sub> shoulders if you are not stripping Kα<sub>2</sub>).</li>
                        <li>Add any missing reflections using <code>Ctrl + Click</code> on the chart.</li>
                    </ul>
                    A clean list of about 15–20 peaks, free of impurities at low angle, is ideal.
                </li>
                <li>
                    <strong>Set parameters.</strong>
                    On the <strong>Parameters</strong> tab:
                    <ul>
                        <li>Select the correct X-ray <code>Radiation Preset</code> (e.g. Cu Kα).</li>
                        <li>Choose whether to enable <code>Strip K-alpha2</code>. This also updates the <code>Ka1 Wavelength</code> field. The default is OFF (average Kα wavelength).</li>
                        <li>Set a chemically reasonable <code>Max Volume (Å³)</code> to limit the search space.</li>
                        <li>Set <code>2θ Error (°)</code> according to your data quality (e.g. ≈0.02° for synchrotron, ≈0.05° for a typical lab diffractometer).</li>
                        <li>Leave <strong>Refine Zero-Point Error</strong> enabled unless you have a specific reason to turn it off.</li>
                        <li>Select the crystal systems to search. Enabling Monoclinic or Triclinic activates GPU-accelerated searches.</li>
                    </ul>
                </li>
                <li>
                    <strong>(Optional) Tune GPU Parameters.</strong>
                    If searching Monoclinic or Triclinic, a new box appears.
                    <ul>
                        <li><code>HKL Basis Size</code>: (Default: 80 for M, 40 for T) Number of simple HKLs to use for the search.</li>
                        <li><code>Peaks to Combine</code>: (Default: 7 for M, 8 for T) Number of observed peaks to use for combinations.</li>
                        <li>Leave these at their defaults unless you have trouble finding a solution.</li>
                    </ul>
                </li>
                <li>
                    <strong>Start indexing.</strong>
                    Click <code>Start Indexing</code>. Progress is shown on the main bar.
                </li>
                <li>
                    <strong>Inspect solutions.</strong>
                    On the <strong>Solutions</strong> tab:
                    <ul>
                        <li>Sort solutions by M(20).</li>
                        <li>Click a row to display calculated (blue) and observed (red) tick marks on the chart.</li>
                        <li>A plausible solution will show excellent alignment and reasonable space-group suggestions.</li>
                    </ul>
                </li>
            </ol>
        </section>

        <!-- UI -->
        <section id="ui">
            <h2>The User Interface</h2>
            <p>
                The application window is divided into a <strong>Controls Panel</strong> (left) and a <strong>Results Area</strong> (right).
            </p>

            <h3>Controls Panel</h3>
            <p>The controls are organized into three main tabs.</p>

            <h4>1. Peaks Tab</h4>
            <ul>
                <li>
                    <strong>Peak finding sliders:</strong>
                    <ul>
                        <li><code>Radius</code> – background subtraction radius (rolling-ball algorithm).</li>
                        <li><code>Points</code> – Savitzky–Golay smoothing window width.</li>
                        <li><code>Min peak (%)</code> – peak detection threshold on a logarithmic scale.</li>
                    </ul>
                </li>
                <li>
                    <strong>2θ range sliders:</strong>
                    Restrict the angular window for peak finding, for example to exclude noisy low-angle or high-angle regions.
                </li>
                <li>
                    <strong>Peak table:</strong>
                    Lists all detected peaks. The <code>2θ Obs (°)</code> column is editable to allow fine corrections.
                </li>
            </ul>

            <h4>2. Parameters Tab</h4>
            <ul>
                <li>
                    <strong>Radiation Preset:</strong>
                    Select the X-ray source (e.g. Cu Kα, Co Kα). This sets the internal wavelength values.
                </li>
                <li>
                    <strong>Ka1 Wavelength (Å):</strong>
                    Displays the wavelength used for calculations. It is updated automatically when a preset is chosen and
                    depends on the <code>Strip K-alpha2</code> setting. It becomes editable only when a <code>Custom</code> preset is selected.
                </li>
                <li>
                    <strong>Strip K-alpha2:</strong>
                    Applies a vanCittert-type correction to remove the Kα<sub>2</sub> component before peak analysis.
                    When enabled, the <code>Ka1 Wavelength</code> field is set to the pure Kα<sub>1</sub> value.
                    The default is OFF.
                </li>
                <li>
                    <strong>Max Volume (Å³):</strong>
                    Upper bound on the allowed unit-cell volume. This is a strong constraint on the search.
                </li>
                <li>
                    <strong>Impurity Peaks:</strong>
                    Number of unindexed peaks allowed among the first 20 when computing M(20).
                </li>
                <li>
                    <strong>2θ Error (°):</strong>
                    Matching tolerance between observed and calculated peak positions.
                </li>
                <li>
                    <strong>Refine Zero-Point Error:</strong>
                    When enabled, a full zero-point refinement is performed for the final solution.
                </li>
                <li>
                    <strong>Crystal systems to search:</strong>
                    Checkboxes for Cubic, Tetragonal, Hexagonal, Orthorhombic, Monoclinic, and Triclinic.
                </li>
            </ul>

       

            <h4 style="margin-top: 2em;">GPU Search Parameters</h4>
            <p>
                When <code>Orthorhombic</code>, <code>Monoclinic</code>, or <code>Triclinic</code> is selected, this section appears, allowing you to control the scope of the GPU-accelerated search.
            </p>
            <ul>
                <li>
                    <strong>HKL Basis Size:</strong>
                    Controls how many simple HKL triplets (from a pre-generated list) are used in the search combinations.
                    <br><em>(Default: 300 for Orthorhombic, 80 for Monoclinic, 40 for Triclinic. Range: 10-600)</em>
                </li>
                <li>
                    <strong>Peaks to Combine:</strong>
                    Controls how many of your observed peaks (from the top of the peak list) are used to generate combinations.
                    <br><em>(Default: 5 for Orthorhombic, 7 for Monoclinic, 8 for Triclinic. Min: 3/4/6)</em>
                </li>
            </ul>


            <p>
                When you select a GPU system, the status text at the bottom of the panel will show you the total number of cells to be tested, which is a direct result of these two parameters. Be careful, this number can increase very fast. For a regular GPU card at the time of this writting (like Nvidia 8Gb T1000) the search speed is in the range of millions/sec cells tested.
            </p>

            <h4>3. Solutions Tab</h4>
            <ul>
                <li>
                    <strong>Solutions table:</strong>
                    Shows each valid solution with crystal system, unit-cell parameters, volume and M(20).
                    Selecting a row updates the main chart.
                    After the search finishes, you can filter visible solutions by enabling or disabling crystal systems.
                </li>
            </ul>

            <h3>Results Area</h3>
            <ul>
                <li>
                    <strong>Chart:</strong>
                    Shows the experimental diffraction pattern, observed peaks (red ticks) and calculated peaks for the
                    selected solution (blue ticks). A good solution exhibits visually convincing overlap.
                </li>
                <li>
                    <strong>Chart interaction:</strong>
                    <ul>
                        <li>Zoom: mouse wheel (different zoom type if the mouse at the left of Y axis or nelow the Y axis).</li>
                        <li>Pan: click and drag.</li>
                        <li>Reset zoom: right-click.</li>
                        <li>Add peak: <code>Ctrl + Click</code>.</li>
                    </ul>
                </li>
            </ul>
        </section>

        <!-- PEAK FINDING -->
        <section id="peak-finding">
            <h2>Peak Finding in Detail</h2>
            <p>
                Accurate peak positions are the single most important input for successful indexing.
                Brutus uses a multi-step procedure to detect peaks from raw intensity data.
            </p>

            <h3>Algorithm Steps</h3>
            <ol>
                <li>
                    <strong>Kα<sub>2</sub> stripping (optional):</strong>
                    If <code>Strip K-alpha2</code> is enabled, the van Cittert algorithm is applied to the raw intensities.
                </li>
                <li>
                    <strong>Background subtraction:</strong>
                    A rolling-ball style algorithm estimates and removes the background.
                    The <code>Radius</code> slider controls the ball radius.
                </li>
                <li>
                    <strong>Data smoothing:</strong>
                    A Savitzky–Golay filter is applied to the background-subtracted signal to reduce noise
                    while preserving peak shapes. The <code>Points</code> slider sets the window width.
                </li>
                <li>
                    <strong>Initial peak detection:</strong>
                    Local maxima above the <code>Min peak (%)</code> threshold are identified.
                </li>
                <li>
                    <strong>Position refinement:</strong>
                    For each peak, a five-point least-squares quadratic fit (based on Savitzky–Golay coefficients) is carried out around
                    the maximum to obtain a the position. If too close to the data edge, the algorithm falls back to a three-point fit.
                </li>
            </ol>

            <h3>Practical Recommendations</h3>
            <ul>
                <li>Start from the default slider values and inspect the result visually. Only the peaks shown in the table will be used in the calculations.</li>
                <li>If weak but real peaks are missed, reduce <code>Min peak (%)</code>. If noise is detected as peaks, increase it.</li>
                <li>For broad, slowly varying backgrounds, increase <code>Radius</code>.</li>
                <li>For noisy data, increase <code>Points</code> (smoothing), but avoid over-smoothing, which can merge or shift peaks.</li>
                <li>
                    Always manually curate the final peak list. Remove artifacts and known impurity peaks.
                    If you are not stripping Kα<sub>2</sub>, delete Kα<sub>2</sub> shoulders explicitly.
                </li>
                <li>
                    Kα<sub>2</sub> stripping can simplify the pattern but may introduce small artifacts.
                    If indexing fails with stripping ON, try turning it OFF and manually cleaning the peak list.
                </li>
            </ul>
        </section>


        <!-- INDEXING METHOD -->
<section id="indexing-method">
    <h2>Indexing Algorithm and Search Parameters</h2>
    <p>
      Brutus uses an exhaustive, symmetry-specific trial-and-refine indexing algorithm.
       For each crystal system, the program generates trial solutions from combinations of the lowest-angle peaks and low-index Miller indices, solves the corresponding linear system of equations in reciprocal space, rejects unphysical cells, and finally performs a full refinement and figure-of-merit evaluation.
    </p>

    <h3>Linear System Formulation</h3>
    <p>
        The search is formulated as a system of linear equations:
    </p>
    <p>
        $$ Q_{obs} = \sum P_i \cdot H_i $$
    </p>
    <p>
        where $Q_{obs}$ are the observed $1/d^2$ values, $H_i$ are terms derived from trial Miller indices
        (e.g. $h^2$, $k^2$, $l^2$), and $P_i$ are the reciprocal lattice parameters (e.g. $A = 1/a^2$, $B = 1/b^2$, …).
    </p>

    <h3>CPU Searches (Cubic, Tetra, Hexa)</h3>
    <ul>
        <li>
            <strong>Cubic (1 parameter, $A = 1/a^2$)</strong><br>
            Solves a 1×1 system by iterating through the first 12 observed peaks and assigning trial $(hkl)$ vectors (integers up to 8), this requires 2448 direct solves.
        </li>

        <li>
            <strong>Tetragonal & Hexagonal (2 parameters)</strong><br>
            Solves all the combinations of a 2×2 system using pairs of peaks from the first 12, assigning pairs of trial $(hkl)$ vectors up to 5; 34 million tests.
        </li>
    </ul>










    
<h3 style="margin-top: 2.5em;">GPU-Accelerated Searches (Orthorhombic, Monoclinic & Triclinic)</h3>
    <p>
        For low-symmetry systems and orthorhombic, the number of combinations becomes too large for the CPU. These searches are offloaded to the WebGPU. Their scope is now user-configurable.
    </p>
    
    <h4>GPU Search Parameters</h4>
    <p>
        You can now control the two key inputs for the GPU search:
    </p>
    <ul>
        <li>
            <code><strong>Peaks to Combine</strong></code>: This sets $N_p$, the number of observed peaks from your list used to generate combinations. The program calculates $C(N_p, k)$, where $k=3$ for orthorhombic, $k=4$ for monoclinic, and $k=6$ for triclinic.
            <br><em>(Defaults: $N_p=5$ for Orthorhombic, $N_p=7$ for Monoclinic, $N_p=8$ for Triclinic)</em>
        </li>
        <li>
            <code><strong>HKL Basis Size</strong></code>: This sets $N_h$, the number of simple HKL vectors used as the "basis set". The program calculates $C(N_h, k)$.
            <br><em>(Defaults: $N_h=300$ for Orthorhombic, $N_h=80$ for Monoclinic, $N_h=40$ for Triclinic)</em>
        </li>
    </ul>
    <blockquote style="margin-top: 1.5em; margin-bottom: 1.5em;">
        <strong>Note on HKL Basis Generation (Axial Promotion)</strong>
        <p style="margin-bottom: 0;">
            For the Orthorhombic and Monoclinic systems, the HKL basis is generated with a special "promotion" step. 
            This ensures that essential reflections for long axes (e.g., <code>(0 0 10)</code>) are not accidentally cut off, which dramatically improves the indexing stability for highly skewed or anisotropic cells.
        </p>
    </blockquote>
    <p>
        The total number of cells tested (which is displayed in the status text) is:
        <br>
        <strong>Total Cells = $C(N_p, k) \times C(N_h, k) \times k!$</strong>
    </p>
    <p>
        where the number of permutations is defined by k: $k=3$ ($k!=6$) for Orthorhombic, $k=4$ ($k!=24$) for Monoclinic, and $k=6$ ($k!=720$) for Triclinic.
    </p>

    <h4>Orthorhombic (3 parameters, $A, B, C$)</h4>
    <ul>
        <li>
            <strong>Logic:</strong> Solves a 3x3 system $M \cdot \vec{x} = \vec{q}$ for $\vec{x} = [A, B, C]$.
        </li>
        <li>
            <strong>GPU Work:</strong> Each GPU thread tests one (peak combo, HKL combo) pair, and loops 6 times (3!) to test all permutations.
        </li>
        <li>
            <strong>Defaults:</strong> $C(5, 3) \times C(300, 3) \times 6 \approx$ <strong>268 million</strong> trial cells.
        </li>
    </ul>

    <h4>Monoclinic (4 parameters, $A, B, C, D$)</h4>
    <ul>
        <li>
            <strong>Logic:</strong> Solves a 4x4 system $M \cdot \vec{x} = \vec{q}$ for $\vec{x} = [A, B, C, D]$.
        </li>
        <li>
            <strong>GPU Work:</strong> Each GPU thread tests one (peak combo, HKL combo) pair, and loops 24 times (4!) to test all permutations.
        </li>
        <li>
            <strong>Defaults:</strong> $C(7, 4) \times C(80, 4) \times 24 \approx$ <strong>1.33 billion</strong> trial cells.
        </li>
    </ul>

    <h4>Triclinic (6 parameters, $A \dots F$)</h4>
    <ul>
        <li>
            <strong>Logic:</strong> Solves the full 6x6 system $M \cdot \vec{x} = \vec{q}$ for $\vec{x} = [A, B, C, D, E, F]$.
        </li>
        <li>
            <strong>GPU Work:</strong> Each GPU thread tests one (peak combo, HKL combo) pair, and loops 720 times (6!) to test all permutations.
        </li>
        <li>
            <strong>Defaults:</strong> $C(8, 6) \times C(40, 6) \times 720 \approx$ <strong>77.4 billion</strong> trial cells.
        </li>
    </ul>

    <h4>Two-Stage GPU Filtering</h4>
    <p>
        Most of these candidate cells are discarded on the GPU before they reach the CPU:
    </p>
    <ol>
        <li>
            <strong>Stage 1 – Basic filter (<code>extractCell</code>):</strong>
            A candidate is immediately rejected if the system is singular, parameters are unphysical (e.g., $a < 2Å$), angles are invalid (e.g., $\beta > 150^\circ$), or the volume exceeds <code>Max Volume</code>.
        </li>
        <li>
            <strong>Stage 2 – Mini Figure of Merit (<code>validate_fom_avg_diff</code>):</strong>
            For surviving cells, the GPU computes a fast Figure of Merit by comparing the first 20 observed peaks to the cell's theoretical pattern. Only cells that pass a strict internal threshold are sent back to the CPU.
        </li>
    </ol>
    
    <h3 id="tuning-the-search">Tuning the Search & Troubleshooting</h3>
    <p>
        If you obtain no solutions, or too many, consider the following adjustments.
    </p>

    <h4>If no solutions (or only poor ones) are found</h4>
    <ul>
        <li>
            <strong>Re-examine the peak list.</strong>
            This is the dominant failure mode. Check that the first 10–15 peaks belong to a single phase,
            are free of impurities, and have accurate $2\theta$ positions.
        </li>
        <li>
            <strong>Relax <code>2θ Error</code>.</strong>
            If this value is too strict for your data resolution, valid solutions may be discarded.
        </li>
        <li>
            <strong>Increase <code>Max Volume</code>.</strong>
            The true cell may be larger than initially expected.
        </li>
        <li>
            <strong>Increase GPU Parameters.</strong>
            Try increasing <code>HKL Basis Size</code> (e.g., from 80 to 120) or <code>Peaks to Combine</code> (e.g., from 7 to 9). This will significantly increase the search time but covers more combinations.
        </li>
    </ul>

    <h4>If you get too many solutions (GPU buffer fills)</h4>
    <p>
        The GPU buffer is now limited to 20,000 candidate solutions. If this buffer fills up, the search stops earlier than the full space requested. If you have no solution that appears valid:
    </p>
    <ul>
        <li>
            <strong>Tighten <code>2θ Error</code>.</strong>
            This is the most effective way to reduce the number of false positives.
        </li>
        <li>
            <strong>Reduce <code>Max Volume</code>.</strong>
            This is another strong constraint to remove unphysical large cells.
        </li>
        <li>
            <strong>Decrease GPU Parameters.</strong>
            Reducing <code>HKL Basis Size</code> or <code>Peaks to Combine</code> will run a smaller, faster search, but may miss the solution if it relies on a higher-index HKL or a peak further down the list.
        </li>
    </ul>

    <h4>GPU Buffers and Chunking</h4>
    <p>
        The total list of HKL combinations can be too large for a single GPU buffer. Brutus therefore:
    </p>
    <ol>
        <li>
            Generates HKL combinations in large JavaScript chunks in <code>brutus.html</code>.
        </li>
        <li>
            Further splits each of these into small “dispatch chunks” (e.g. 256 workgroups) in
            <code>webgpu-engine.js</code> before sending them to the GPU.
        </li>
    </ol>
    <p>
        This two-level chunking avoids both memory overflow and long-running GPU commands.
    </p>
    <blockquote>
        <strong>Performance: WebGPU vs CPU</strong>
        <p>
            Cubic, Tetragonal, and Hexagonal searches run on the CPU (in a Web Worker) and are typically
            very fast (under a second).
        </p>
        <p>
            Orthorhombic, Monoclinic, and Triclinic searches are offloaded to the GPU. This allows testing of billions of trial cells in a time frame (few minutes for 1 billion cells) that would be
            impractical on the CPU. 
        </p>
        <p>
            Note: at the end of a GPU search all candidates (up to 20 000) are passed to refinement, Niggli cell reduction, M(20) and F(N) calculations. These are made on the CPU so it might take a few minutes, be patient (or change the parameters, or decrease the number of peaks in the list).
        </p>
    </blockquote>



    <h3 id="tuning-the-search">Tuning the Search & Troubleshooting</h3>
    <p>
        If you obtain no solutions, or too many, consider the following adjustments.
    </p>

    <h4>If no solutions (or only poor ones) are found</h4>
    <ul>
        <li>
            <strong>Re-examine the peak list.</strong>
            This is the dominant failure mode. Check that the first 10–15 peaks belong to a single phase,
            are free of impurities, and have accurate $2\theta$ positions.
        </li>
        <li>
            <strong>Relax <code>2θ Error</code>.</strong>
            If this value is too strict for your data resolution, valid solutions may be discarded.
        </li>
        <li>
            <strong>Increase <code>Max Volume</code>.</strong>
            The true cell may be larger than initially expected.
        </li>
        <li>
            <strong>Increase GPU Parameters.</strong>
            Try increasing <code>HKL Basis Size</code> (e.g., from 80 to 120) or <code>Peaks to Combine</code> (e.g., from 7 to 9). This will significantly increase the search time but covers more combinations.
        </li>
    </ul>

    <h4>If you get too many solutions (GPU buffer fills)</h4>
    <p>
        The GPU buffer is now limited to 20,000 candidate solutions. If this buffer fills up, the search stops earlier than the full space requested. If you have no solution that appears valid:
    </p>
    <ul>
        <li>
            <strong>Tighten <code>2θ Error</code>.</strong>
            This is the most effective way to reduce the number of false positives.
        </li>
        <li>
            <strong>Reduce <code>Max Volume</code>.</strong>
            This is another strong constraint to remove unphysical large cells.
        </li>
        <li>
            <strong>Decrease GPU Parameters.</strong>
            Reducing <code>HKL Basis Size</code> or <code>Peaks to Combine</code> will run a smaller, faster search, but may miss the solution if it relies on a higher-index HKL or a peak further down the list.
        </li>
    </ul>

    <h4>GPU Buffers and Chunking</h4>
    <p>
        The total list of HKL combinations can be too large for a single GPU buffer. Brutus therefore:
    </p>
    <ol>
        <li>
            Generates HKL combinations in large JavaScript chunks in <code>brutus.html</code>.
        </li>
        <li>
            Further splits each of these into small “dispatch chunks” (e.g. 256 workgroups) in
            <code>webgpu-engine.js</code> before sending them to the GPU.
        </li>
    </ol>
    <p>
        This two-level chunking avoids both memory overflow and long-running GPU commands.
    </p>
    <blockquote>
        <strong>Performance: WebGPU vs CPU</strong>
        <p>
            Cubic, Tetragonal and Hexagonal searches run on the CPU (in a Web Worker) and are typically
            very fast, of the order of a few seconds. 
        </p>
        <p>
            Monoclinic and Triclinic searches are offloaded to the GPU. This allows testing of billions of trial cells in a time frame (few minutes for 1 billion cells) that would be
            impractical on the CPU. The user can stop the search if a good solution is found.
        </p>
        <p>
            Note: at the end of a GPU search all candidates (up to 10 000) are passed to refinement, Niggli cell reduction, M(20) and F(N) calculations. These are made on the CPU so it might take a few minutes, be patient. 
        </p>
    </blockquote>
</section>


        <!-- EVALUATING SOLUTIONS -->
        <section id="evaluating-solutions">
            <h2>Evaluating Solutions</h2>
            <p>
                The indexing search usually produces several candidate cells. Brutus keeps at most the best 50, ranked by M20, after the search.
                Selecting the correct one requires interpreting figures of merit and checking the refined fit.
            </p>

            <h3>de Wolff Figure of Merit: M(20)</h3>
            <p>
                The primary ranking indicator is the <strong>de Wolff Figure of Merit, M(20)</strong>, calculated from
                the first 20 observed reflections. It combines both positional accuracy and completeness. In the PDF report additional values are listed, for instance F(20). 
            </p>
            <table>
                <thead>
                    <tr><th>M(20) value</th><th>Interpretation</th></tr>
                </thead>
                <tbody>
                    <tr><td>&gt; 20</td><td>Very likely correct.</td></tr>
                    <tr><td>&gt; 10</td><td>Likely correct, provided the cell volume is chemically plausible.</td></tr>
                    <tr><td>5–10</td><td>Plausible; requires further inspection.</td></tr>
                    <tr><td>&lt; 5</td><td>Probably spurious; treat with caution.</td></tr>
                </tbody>
            </table>

            <h3>F(N) Figure of Merit</h3>
            <p>
                As a complementary metric, Brutus computes the <strong>F(N)</strong> figure of merit, usually with N = 20 (F(20)).
                While M(20) emphasizes the completeness of indexing, F(N) focuses on the average positional accuracy.
            </p>
            <p>
                $$ F_N = \frac{N}{\langle |\Delta(2\theta)| \rangle \cdot N_{calc}} $$
            </p>
            <ul>
                <li>$N$ – number of observed lines used (e.g. 20).</li>
                <li>$\langle |\Delta(2\theta)| \rangle$ – mean absolute difference between observed and calculated $2\theta$ for those lines.</li>
                <li>$N_{calc}$ – number of theoretical reflections (observed or not) up to the $2\theta$ of the $N$-th observed line.</li>
            </ul>
            <p>
                A high F(20) indicates a precise fit with low average error. A solution with both high M(20) and high F(20)
                is usually reliable.
            </p>

            <h3>Least-Squares and Zero-Point Refinement</h3>
            <p>
                For each promising candidate, Brutus performs a two-stage refinement.
            </p>

            <h4>Stage 1: Internal zero-point correction</h4>
            <p>
                First, a constrained refinement is carried out including a zero-point error parameter.
                This internal zero correction is limited by the user-defined <code>2θ Error</code>, which allows
                the algorithm to compensate for modest alignment errors without overfitting. The corrected
                peak positions are then used to refine a stable baseline cell.
            </p>

            <h4>Stage 2: Final refinement (optional)</h4>
            <p>
                If the Stage-1 cell achieves a sufficiently high M(20) and the
                <code>Refine Zero-Point Error</code> option is enabled, a second, full refinement (with an
                unconstrained zero-point) is performed. This yields the final reported parameters and standard deviations.
                If the option is disabled, the Stage-1 cell parameters are reported directly.
            </p>
        </section>

        <!-- SPACE GROUP ANALYSIS -->
        <section id="space-group-analysis">
            <h2>Space Group Analysis</h2>
            <p>
                After a high-quality unit cell is obtained, Brutus can suggest likely space groups based
                on systematic absences. This serves as input for subsequent structure solution or Rietveld refinement.
            </p>

            <h3>Method</h3>
            <ol>
                <li>
                    <strong>Generate unique reflections.</strong>
                    Using the refined cell, Brutus computes a complete list of theoretical reflections and keeps
                    only crystallographically unique ones (e.g. it includes (100) but omits Friedel equivalent (−100)).
                </li>
                <li>
                    <strong>Index observed peaks.</strong>
                    All peaks in the curated list are indexed against the theoretical pattern.
                </li>
                <li>
                    <strong>Build a high-confidence subset.</strong>
                    To avoid ambiguity due to overlapping lines, Brutus retains only reflections for which no other
                    theoretical $(hkl)$ lies within the <code>2θ Error</code> window of the observed peak.
                </li>
                <li>
                    <strong>Determine centering and extinctions.</strong>
                    This subset of unambiguous $(hkl)$ indices is compared with the extinction rules of
                    candidate lattices (centerings and glide/screw symmetries). A rule is considered violated only if
                    an <em>observed unambiguous</em> peak contradicts it.
                </li>
                <li>
                    <strong>Rank space groups.</strong>
                    Based on the crystal system and plausible centerings, the internal database is filtered.
                    Each space group is assigned a violation count and ranked accordingly. The correct name of the space group is given, based on the orientation found by the program. 
                </li>
            </ol>

            <h3>Interpreting the Output</h3>
            <ul>
                <li>
                    <strong>0 violations:</strong>
                    Ideal case. No unambiguous reflection breaks the extinction rules; these are the strongest candidates.
                </li>
                <li>
                    <strong>1–2 violations:</strong>
                    Still plausible; minor violations can result from weak forbidden lines or experimental artifacts.
                </li>
                <li>
                    <strong>Ambiguous peaks in italics:</strong>
                    In the PDF report, peaks classified as ambiguous (and therefore excluded from extinction analysis)
                    are printed in italics to distinguish them from the high-confidence subset.
                </li>
            </ul>
        </section>

        <!-- ADVANCED TOPICS -->
        <section id="advanced-topics">
            <h2>Advanced Topics: Enhanced Search and Sieving</h2>
            <p>
                Beyond the core indexing routine, Brutus applies several “fishing” strategies and reduction steps
                to improve robustness and simplify the set of final solutions.
            </p>

            <h3>1. Swap Fishing for Ambiguity</h3>
            <p>
                For each promising solution, Brutus re-examines the indexing of the first four low-angle peaks.
                It identifies the two peaks closest in angle (a common source of mis-assignment) and creates a new
                hypothesis by swapping their HKL labels. The resulting cell is fully refined and rescored.
                If this swap resolves an ambiguity, the new solution might have a higher M(20) and this solution will be retained.
            </p>

            <h3>2. Matrix-Based Cell Transformations</h3>
            <p>
                Candidate cells are transformed using crystallographic matrices to test for related primitive
                or higher-symmetry descriptions. For example, a body-centered (I) cell can be mapped to an
                equivalent primitive (P) cell and evaluated.
            </p>

            <h3>3. HKL Divisor Analysis</h3>
            <p>
                The list of indexed HKLs is inspected for common divisors. If all indices along one axis
                (e.g. all <em>h</em> values) share a common factor, Brutus tests a cell with the corresponding
                axis shortened accordingly (sub-cell).
            </p>

            <h3>4. Orthorhombic–Hexagonal Relationship</h3>
            <p>
                A hexagonal lattice can sometimes be indexed as C-centered orthorhombic with
                $b/a \approx \sqrt{3}$. All orthorhombic solutions are checked against this condition,
                and potential hexagonal equivalents are generated and evaluated.
            </p>

            <h3>5. Niggli Cell Standardization</h3>
            <p>
                For each high-ranking solution, Brutus computes the <strong>Niggli reduced cell</strong>,
                i.e. the standardized primitive cell describing the same lattice.
            </p>
            <p>
                The conventional (possibly centered) cell identified by the program is first converted to a primitive cell
                using the detected centering (e.g. I, F, C). A reduction algorithm is then applied to obtain the
                most compact set of basis vectors ($a, b, c$) and angles ($\alpha, \beta, \gamma$) satisfying
                the Niggli conditions.
            </p>
            <p>
                The Niggli cell is useful for:
            </p>
            <ul>
                <li>
                    <strong>Database searching:</strong> Different conventional cells that represent the same lattice
                    reduce to the same Niggli cell, which can be used as a canonical key.
                </li>
                <li>
                    <strong>Symmetry analysis:</strong> Niggli parameters correlate directly with Bravais lattices
                    and crystal systems.
                </li>
                <li>
                    <strong>Standardized reporting:</strong> It removes ambiguity when comparing unit cells between sources.
                </li>
            </ul>
            <p>
                Niggli cells are included in the detailed section of the PDF report for each major candidate.
            </p>

            <h3>6. Final Sieving</h3>
            <p>
                After all transformations and refinements, Brutus applies a final de-duplication step.
                If two solutions have volumes within 1% of each other, the one with higher symmetry is preferred.
            </p>
            <p>
                If their symmetry is identical (e.g. two monoclinic cells), M(20) is compared.
                Cells with M(20) values within a small tolerance (e.g. ΔM(20) &lt; 0.05) are considered equivalent in
                quality and the first solution found is retained.
            </p>
            
        </section>

        <!-- TROUBLESHOOTING -->
        <section id="troubleshooting">
            <h2>Troubleshooting & FAQ</h2>

            <h3>Why were no solutions found?</h3>
            <ul>
                <li>
                    <strong>Poor peak list:</strong>
                    This is the most common cause. Ensure the list is accurate, impurity peaks are removed,
                    and positions are refined. A minimum of 15–20 clean peaks is recommended.
                    For low symmetry, the first 10 peaks (largest d-spacings) must be especially reliable.
                </li>
                <li>
                    <strong>Incorrect parameters:</strong>
                    Check the wavelength, the selected <code>Radiation Preset</code>, and the <code>Max Volume</code> value.
                </li>
                <li>
                    <strong>GPU parameters are too restrictive:</strong>
                    The true solution might require HKLs or peaks beyond the default <code>HKL Basis Size</code> or <code>Peaks to Combine</code>. Try increasing these values.
                </li>
                <li>
                    <strong>Large zero-point error:</strong>
                    Brutus can correct moderate misalignments, but very large zero errors may still prevent indexing.
                </li>
                <li>
                    <strong>Sample is a mixture:</strong>
                    Successful indexing requires peaks from a single crystalline phase.
                </li>
            </ul>

            <h3>Why is M(20) low although the fit looks good?</h3>
            <ul>
                <li>
                    <strong>Sub-multiple or super-multiple cell:</strong>
                    The found cell may be a multiple or sub-cell of the true one. It can index only a subset of peaks
                    and is penalized for being too sparse or too dense in calculated reflections.
                </li>
                <li>
                    <strong>High error / low resolution:</strong>
                    The <code>2θ Error</code> setting may be too strict for broad peaks. Try slightly increasing it.
                </li>
                <li>
                    <strong>Spurious solution:</strong>
                    Random solutions can fit a few peaks by chance. Always check whether major observed peaks are
                    reproduced by the calculated pattern. If not, the solution is incorrect regardless of M(20).
                </li>
            </ul>

            <h3>Test Files</h3>
            <ul>
                <li>The GitHub repository contains several example data sets:</li>
                <li>
                    <strong>Monoclinic_test_1.xy</strong> –
                    Synchrotron XRD, monoclinic, monochromatic radiation λ = 0.79764 Å.
                    Lattice parameters: a = 19.877 Å, b = 8.196 Å, c = 11.243 Å, β = 106.08°.
                </li>
                <li>
                    <strong>C61Br2_079764.XY</strong> –
                    Dibromo-methano fullerene measured at ESRF, λ = 0.79764 Å.
                    Contains an impurity peak at about 16.24° 2θ.
                    A likely solution is cubic I with a ≈ 18.92 Å.
                </li>
                <li>
                    <strong>SPDDRR1_sample2_0692.xy</strong> –
                    Round-robin data measured at Daresbury, λ = 0.692 Å.
                    Probable cell: orthorhombic with a = 10.983 Å, b = 12.852 Å, c = 15.740 Å.
                </li>
                <li>
                    <strong>SPDDRR1_sample2_Cu.xy</strong> –
                    Same sample as above, measured with a Cu Kα laboratory source.
                </li>
                <li>
                    <strong>SPDDRR1_zhu1_Cu.xy</strong> –
                    Round-robin sample 1, measured with Cu Kα; likely monoclinic with
                    a = 7.672 Å, b = 9.624 Å, c = 7.076 Å, β = 106.24°.
                </li>
                <li>
                    <strong>PbSO4.xra</strong> and <strong>FAP.xra</strong> –
                    Laboratory Cu Kα samples representative of orthorhombic and hexagonal structures (these datafiles were taken from GSAS-2 tutorials).
                </li>
                <li>
                    <strong>P-1_sim_5_6_7_86_91_96.txt</strong> –
                    Simulated powder pattern for a P−1 lattice, λ = 1.7 Å,
                    a = 5.0 Å, b = 6.0 Å, c = 7.0 Å, α = 86.0°, β = 91.0°, γ = 96.0°.
                </li>
            </ul>
        </section>

        <!-- REFERENCES -->
        <section id="references">
            <h2>References</h2>
            <p>
                Brutus was developed by Nita Dragoe at Université Paris-Saclay (2024–2025) as a successor to the earlier
                program <em>Powder</em> (1999–2000). If you use Brutus in your work, please cite:
                <br>
                <a href="https://doi.org/10.13140/RG.2.2.13443.57126">
                    https://doi.org/10.13140/RG.2.2.13443.57126
                </a>
            </p>
            <p>
                For further background on the methodology, the following references are recommended:
            </p>
            <ol>
                <li>
                    <strong>M(20) figure of merit</strong><br>
                    de Wolff, P. M. (1968).
                    “A Simplified Criterion for the Reliability of a Powder Pattern Indexing.”
                    <em>Journal of Applied Crystallography</em> <strong>1</strong>, 108–113.
                </li>
                <li>
                    <strong>F(N) figure of merit</strong><br>
                    Smith, G. S. &amp; Snyder, R. L. (1979).
                    “F(N): A Criterion for Rating Powder Diffraction Patterns and Evaluating the Reliability of Powder-Pattern Indexing.”
                    <em>Journal of Applied Crystallography</em> <strong>12</strong>, 60–65.
                </li>
                <li>
                    <strong>General powder diffraction text</strong><br>
                    Klug, H. P. &amp; Alexander, L. E. (1974).
                    <em>X-Ray Diffraction Procedures for Polycrystalline and Amorphous Materials</em>, 2nd ed.
                    New York: Wiley-Interscience.
                </li>

                <li>
                <strong>Deconvolution Algorithm (van Cittert):</strong><br>
                van Cittert, P. H. (1931).
                “Zum Einfluß der Spaltbreite auf die Intensitätsverteilung in Spektrallinien II.”
                <em>Zeitschrift für Physik</em>, <strong>69</strong>, 298–308.
            </li>
                <li>
                    <strong>Alternative indexing approaches</strong><br>
                    Ito, T. (1949). “A General Powder X-ray Photography.” <em>Nature</em> <strong>164</strong>, 755–756.<br>
                    Werner, P.-E., Eriksson, L. &amp; Westdahl, M. (1985).
                    “TREOR, a Semi-exhaustive Trial-and-Error Powder Indexing Program for All Symmetries.”
                    <em>Journal of Applied Crystallography</em> <strong>18</strong>, 367–370.<br>
                    Visser, J. W. (1969).
                    “A Fully Automatic Program for Finding the Unit Cell from Powder Data.”
                    <em>Journal of Applied Crystallography</em> <strong>2</strong>, 89–95.<br>
                    Le Bail, A. (2004).
                    “Monte Carlo Indexing with McMaille.” <em>Powder Diffraction</em> <strong>19(3)</strong>, 249–254.<br>
                    Boultif, A. &amp; Louër, D. (2004).
                    “Powder Pattern Indexing with the Dichotomy Method.”
                    <em>Journal of Applied Crystallography</em> <strong>37</strong>, 724–731.
                </li>
                <li>
                    <strong>Previous software</strong><br>
                    Dragoe, N. (2001).
                    “PowderV2: A Suite of Applications for Powder X-Ray Diffraction Calculations.”
                    <em>Journal of Applied Crystallography</em> <strong>34</strong>, 535.
                </li>
            </ol>

            <div class="footer">
                <p>Help guide generated with the assistance of an AI, last updated 16 November 2025.</p>
            </div>
        </section>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const sections = document.querySelectorAll('section');
            const navLinks = document.querySelectorAll('#toc a');
            const mainContent = document.getElementById('main-content');

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const id = entry.target.getAttribute('id');
                        navLinks.forEach(link => link.classList.remove('active'));
                        const activeLink = document.querySelector(`#toc a[href="#${id}"]`);
                        if (activeLink) activeLink.classList.add('active');
                    }
                });
            }, { root: mainContent, rootMargin: "0px 0px -80% 0px" });

            sections.forEach(section => observer.observe(section));

            navLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    navLinks.forEach(l => l.classList.remove('active'));
                    this.classList.add('active');
                    const targetId = this.getAttribute('href');
                    const targetElement = document.querySelector(targetId);

                    if (targetElement) {
                        mainContent.scrollTo({
                            top: targetElement.offsetTop - 32,
                            behavior: 'smooth'
                        });
                    }
                });
            });

            const updateActiveLink = () => {
                let currentActive = '';
                sections.forEach(section => {
                    const rect = section.getBoundingClientRect();
                    if (rect.top >= 0 && rect.top <= mainContent.clientHeight * 0.2) {
                        currentActive = section.getAttribute('id');
                    }
                });

                if (currentActive) {
                    navLinks.forEach(link => link.classList.remove('active'));
                    const activeLink = document.querySelector(`#toc a[href="#${currentActive}"]`);
                    if (activeLink) activeLink.classList.add('active');
                } else {
                    if (mainContent.scrollTop < sections[0].offsetTop + sections[0].offsetHeight) {
                        navLinks.forEach(link => link.classList.remove('active'));
                        if (navLinks.length > 0) navLinks[0].classList.add('active');
                    }
                }
            };

            mainContent.addEventListener('scroll', updateActiveLink);
            setTimeout(updateActiveLink, 150);
        });
    </script>
</body>
</html>